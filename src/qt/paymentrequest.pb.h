// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: paymentrequest.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020002 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_paymentrequest_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_paymentrequest_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_paymentrequest_2eproto;
namespace payments {
class Output;
struct OutputDefaultTypeInternal;
extern OutputDefaultTypeInternal _Output_default_instance_;
class Payment;
struct PaymentDefaultTypeInternal;
extern PaymentDefaultTypeInternal _Payment_default_instance_;
class PaymentACK;
struct PaymentACKDefaultTypeInternal;
extern PaymentACKDefaultTypeInternal _PaymentACK_default_instance_;
class PaymentDetails;
struct PaymentDetailsDefaultTypeInternal;
extern PaymentDetailsDefaultTypeInternal _PaymentDetails_default_instance_;
class PaymentRequest;
struct PaymentRequestDefaultTypeInternal;
extern PaymentRequestDefaultTypeInternal _PaymentRequest_default_instance_;
class X509Certificates;
struct X509CertificatesDefaultTypeInternal;
extern X509CertificatesDefaultTypeInternal _X509Certificates_default_instance_;
}  // namespace payments
PROTOBUF_NAMESPACE_OPEN
template<> ::payments::Output* Arena::CreateMaybeMessage<::payments::Output>(Arena*);
template<> ::payments::Payment* Arena::CreateMaybeMessage<::payments::Payment>(Arena*);
template<> ::payments::PaymentACK* Arena::CreateMaybeMessage<::payments::PaymentACK>(Arena*);
template<> ::payments::PaymentDetails* Arena::CreateMaybeMessage<::payments::PaymentDetails>(Arena*);
template<> ::payments::PaymentRequest* Arena::CreateMaybeMessage<::payments::PaymentRequest>(Arena*);
template<> ::payments::X509Certificates* Arena::CreateMaybeMessage<::payments::X509Certificates>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace payments {

// ===================================================================

class Output final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.Output) */ {
 public:
  inline Output() : Output(nullptr) {}
  ~Output() override;
  explicit PROTOBUF_CONSTEXPR Output(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Output(const Output& from);
  Output(Output&& from) noexcept
    : Output() {
    *this = ::std::move(from);
  }

  inline Output& operator=(const Output& from) {
    CopyFrom(from);
    return *this;
  }
  inline Output& operator=(Output&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Output& default_instance() {
    return *internal_default_instance();
  }
  static inline const Output* internal_default_instance() {
    return reinterpret_cast<const Output*>(
               &_Output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(Output& a, Output& b) {
    a.Swap(&b);
  }
  inline void Swap(Output* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Output* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Output>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Output& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Output& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Output* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.Output";
  }
  protected:
  explicit Output(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 2,
    kAmountFieldNumber = 1,
  };
  // required bytes script = 2;
  bool has_script() const;
  private:
  bool _internal_has_script() const;
  public:
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_NODISCARD std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // optional uint64 amount = 1 [default = 0];
  bool has_amount() const;
  private:
  bool _internal_has_amount() const;
  public:
  void clear_amount();
  uint64_t amount() const;
  void set_amount(uint64_t value);
  private:
  uint64_t _internal_amount() const;
  void _internal_set_amount(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:payments.Output)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  uint64_t amount_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentDetails) */ {
 public:
  inline PaymentDetails() : PaymentDetails(nullptr) {}
  ~PaymentDetails() override;
  explicit PROTOBUF_CONSTEXPR PaymentDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentDetails(const PaymentDetails& from);
  PaymentDetails(PaymentDetails&& from) noexcept
    : PaymentDetails() {
    *this = ::std::move(from);
  }

  inline PaymentDetails& operator=(const PaymentDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentDetails& operator=(PaymentDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentDetails* internal_default_instance() {
    return reinterpret_cast<const PaymentDetails*>(
               &_PaymentDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PaymentDetails& a, PaymentDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaymentDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentDetails";
  }
  protected:
  explicit PaymentDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOutputsFieldNumber = 2,
    kNetworkFieldNumber = 1,
    kMemoFieldNumber = 5,
    kPaymentUrlFieldNumber = 6,
    kMerchantDataFieldNumber = 7,
    kTimeFieldNumber = 3,
    kExpiresFieldNumber = 4,
  };
  // repeated .payments.Output outputs = 2;
  int outputs_size() const;
  private:
  int _internal_outputs_size() const;
  public:
  void clear_outputs();
  ::payments::Output* mutable_outputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
      mutable_outputs();
  private:
  const ::payments::Output& _internal_outputs(int index) const;
  ::payments::Output* _internal_add_outputs();
  public:
  const ::payments::Output& outputs(int index) const;
  ::payments::Output* add_outputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
      outputs() const;

  // optional string network = 1 [default = "main"];
  bool has_network() const;
  private:
  bool _internal_has_network() const;
  public:
  void clear_network();
  const std::string& network() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_network(ArgT0&& arg0, ArgT... args);
  std::string* mutable_network();
  PROTOBUF_NODISCARD std::string* release_network();
  void set_allocated_network(std::string* network);
  private:
  const std::string& _internal_network() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_network(const std::string& value);
  std::string* _internal_mutable_network();
  public:

  // optional string memo = 5;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // optional string payment_url = 6;
  bool has_payment_url() const;
  private:
  bool _internal_has_payment_url() const;
  public:
  void clear_payment_url();
  const std::string& payment_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payment_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payment_url();
  PROTOBUF_NODISCARD std::string* release_payment_url();
  void set_allocated_payment_url(std::string* payment_url);
  private:
  const std::string& _internal_payment_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payment_url(const std::string& value);
  std::string* _internal_mutable_payment_url();
  public:

  // optional bytes merchant_data = 7;
  bool has_merchant_data() const;
  private:
  bool _internal_has_merchant_data() const;
  public:
  void clear_merchant_data();
  const std::string& merchant_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_merchant_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_merchant_data();
  PROTOBUF_NODISCARD std::string* release_merchant_data();
  void set_allocated_merchant_data(std::string* merchant_data);
  private:
  const std::string& _internal_merchant_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_merchant_data(const std::string& value);
  std::string* _internal_mutable_merchant_data();
  public:

  // required uint64 time = 3;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  uint64_t time() const;
  void set_time(uint64_t value);
  private:
  uint64_t _internal_time() const;
  void _internal_set_time(uint64_t value);
  public:

  // optional uint64 expires = 4;
  bool has_expires() const;
  private:
  bool _internal_has_expires() const;
  public:
  void clear_expires();
  uint64_t expires() const;
  void set_expires(uint64_t value);
  private:
  uint64_t _internal_expires() const;
  void _internal_set_expires(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:payments.PaymentDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output > outputs_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr network_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payment_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merchant_data_;
  uint64_t time_;
  uint64_t expires_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentRequest) */ {
 public:
  inline PaymentRequest() : PaymentRequest(nullptr) {}
  ~PaymentRequest() override;
  explicit PROTOBUF_CONSTEXPR PaymentRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentRequest(const PaymentRequest& from);
  PaymentRequest(PaymentRequest&& from) noexcept
    : PaymentRequest() {
    *this = ::std::move(from);
  }

  inline PaymentRequest& operator=(const PaymentRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentRequest& operator=(PaymentRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentRequest* internal_default_instance() {
    return reinterpret_cast<const PaymentRequest*>(
               &_PaymentRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PaymentRequest& a, PaymentRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaymentRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentRequest";
  }
  protected:
  explicit PaymentRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPkiTypeFieldNumber = 2,
    kPkiDataFieldNumber = 3,
    kSerializedPaymentDetailsFieldNumber = 4,
    kSignatureFieldNumber = 5,
    kPaymentDetailsVersionFieldNumber = 1,
  };
  // optional string pki_type = 2 [default = "none"];
  bool has_pki_type() const;
  private:
  bool _internal_has_pki_type() const;
  public:
  void clear_pki_type();
  const std::string& pki_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pki_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pki_type();
  PROTOBUF_NODISCARD std::string* release_pki_type();
  void set_allocated_pki_type(std::string* pki_type);
  private:
  const std::string& _internal_pki_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pki_type(const std::string& value);
  std::string* _internal_mutable_pki_type();
  public:

  // optional bytes pki_data = 3;
  bool has_pki_data() const;
  private:
  bool _internal_has_pki_data() const;
  public:
  void clear_pki_data();
  const std::string& pki_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pki_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pki_data();
  PROTOBUF_NODISCARD std::string* release_pki_data();
  void set_allocated_pki_data(std::string* pki_data);
  private:
  const std::string& _internal_pki_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pki_data(const std::string& value);
  std::string* _internal_mutable_pki_data();
  public:

  // required bytes serialized_payment_details = 4;
  bool has_serialized_payment_details() const;
  private:
  bool _internal_has_serialized_payment_details() const;
  public:
  void clear_serialized_payment_details();
  const std::string& serialized_payment_details() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serialized_payment_details(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serialized_payment_details();
  PROTOBUF_NODISCARD std::string* release_serialized_payment_details();
  void set_allocated_serialized_payment_details(std::string* serialized_payment_details);
  private:
  const std::string& _internal_serialized_payment_details() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serialized_payment_details(const std::string& value);
  std::string* _internal_mutable_serialized_payment_details();
  public:

  // optional bytes signature = 5;
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional uint32 payment_details_version = 1 [default = 1];
  bool has_payment_details_version() const;
  private:
  bool _internal_has_payment_details_version() const;
  public:
  void clear_payment_details_version();
  uint32_t payment_details_version() const;
  void set_payment_details_version(uint32_t value);
  private:
  uint32_t _internal_payment_details_version() const;
  void _internal_set_payment_details_version(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:payments.PaymentRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_pki_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pki_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pki_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serialized_payment_details_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  uint32_t payment_details_version_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class X509Certificates final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.X509Certificates) */ {
 public:
  inline X509Certificates() : X509Certificates(nullptr) {}
  ~X509Certificates() override;
  explicit PROTOBUF_CONSTEXPR X509Certificates(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  X509Certificates(const X509Certificates& from);
  X509Certificates(X509Certificates&& from) noexcept
    : X509Certificates() {
    *this = ::std::move(from);
  }

  inline X509Certificates& operator=(const X509Certificates& from) {
    CopyFrom(from);
    return *this;
  }
  inline X509Certificates& operator=(X509Certificates&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const X509Certificates& default_instance() {
    return *internal_default_instance();
  }
  static inline const X509Certificates* internal_default_instance() {
    return reinterpret_cast<const X509Certificates*>(
               &_X509Certificates_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(X509Certificates& a, X509Certificates& b) {
    a.Swap(&b);
  }
  inline void Swap(X509Certificates* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(X509Certificates* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  X509Certificates* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<X509Certificates>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const X509Certificates& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const X509Certificates& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(X509Certificates* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.X509Certificates";
  }
  protected:
  explicit X509Certificates(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCertificateFieldNumber = 1,
  };
  // repeated bytes certificate = 1;
  int certificate_size() const;
  private:
  int _internal_certificate_size() const;
  public:
  void clear_certificate();
  const std::string& certificate(int index) const;
  std::string* mutable_certificate(int index);
  void set_certificate(int index, const std::string& value);
  void set_certificate(int index, std::string&& value);
  void set_certificate(int index, const char* value);
  void set_certificate(int index, const void* value, size_t size);
  std::string* add_certificate();
  void add_certificate(const std::string& value);
  void add_certificate(std::string&& value);
  void add_certificate(const char* value);
  void add_certificate(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& certificate() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_certificate();
  private:
  const std::string& _internal_certificate(int index) const;
  std::string* _internal_add_certificate();
  public:

  // @@protoc_insertion_point(class_scope:payments.X509Certificates)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> certificate_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class Payment final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.Payment) */ {
 public:
  inline Payment() : Payment(nullptr) {}
  ~Payment() override;
  explicit PROTOBUF_CONSTEXPR Payment(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Payment(const Payment& from);
  Payment(Payment&& from) noexcept
    : Payment() {
    *this = ::std::move(from);
  }

  inline Payment& operator=(const Payment& from) {
    CopyFrom(from);
    return *this;
  }
  inline Payment& operator=(Payment&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Payment& default_instance() {
    return *internal_default_instance();
  }
  static inline const Payment* internal_default_instance() {
    return reinterpret_cast<const Payment*>(
               &_Payment_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Payment& a, Payment& b) {
    a.Swap(&b);
  }
  inline void Swap(Payment* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Payment* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Payment* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Payment>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Payment& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Payment& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Payment* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.Payment";
  }
  protected:
  explicit Payment(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionsFieldNumber = 2,
    kRefundToFieldNumber = 3,
    kMerchantDataFieldNumber = 1,
    kMemoFieldNumber = 4,
  };
  // repeated bytes transactions = 2;
  int transactions_size() const;
  private:
  int _internal_transactions_size() const;
  public:
  void clear_transactions();
  const std::string& transactions(int index) const;
  std::string* mutable_transactions(int index);
  void set_transactions(int index, const std::string& value);
  void set_transactions(int index, std::string&& value);
  void set_transactions(int index, const char* value);
  void set_transactions(int index, const void* value, size_t size);
  std::string* add_transactions();
  void add_transactions(const std::string& value);
  void add_transactions(std::string&& value);
  void add_transactions(const char* value);
  void add_transactions(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transactions() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transactions();
  private:
  const std::string& _internal_transactions(int index) const;
  std::string* _internal_add_transactions();
  public:

  // repeated .payments.Output refund_to = 3;
  int refund_to_size() const;
  private:
  int _internal_refund_to_size() const;
  public:
  void clear_refund_to();
  ::payments::Output* mutable_refund_to(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
      mutable_refund_to();
  private:
  const ::payments::Output& _internal_refund_to(int index) const;
  ::payments::Output* _internal_add_refund_to();
  public:
  const ::payments::Output& refund_to(int index) const;
  ::payments::Output* add_refund_to();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
      refund_to() const;

  // optional bytes merchant_data = 1;
  bool has_merchant_data() const;
  private:
  bool _internal_has_merchant_data() const;
  public:
  void clear_merchant_data();
  const std::string& merchant_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_merchant_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_merchant_data();
  PROTOBUF_NODISCARD std::string* release_merchant_data();
  void set_allocated_merchant_data(std::string* merchant_data);
  private:
  const std::string& _internal_merchant_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_merchant_data(const std::string& value);
  std::string* _internal_mutable_merchant_data();
  public:

  // optional string memo = 4;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // @@protoc_insertion_point(class_scope:payments.Payment)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transactions_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output > refund_to_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr merchant_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// -------------------------------------------------------------------

class PaymentACK final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:payments.PaymentACK) */ {
 public:
  inline PaymentACK() : PaymentACK(nullptr) {}
  ~PaymentACK() override;
  explicit PROTOBUF_CONSTEXPR PaymentACK(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PaymentACK(const PaymentACK& from);
  PaymentACK(PaymentACK&& from) noexcept
    : PaymentACK() {
    *this = ::std::move(from);
  }

  inline PaymentACK& operator=(const PaymentACK& from) {
    CopyFrom(from);
    return *this;
  }
  inline PaymentACK& operator=(PaymentACK&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PaymentACK& default_instance() {
    return *internal_default_instance();
  }
  static inline const PaymentACK* internal_default_instance() {
    return reinterpret_cast<const PaymentACK*>(
               &_PaymentACK_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PaymentACK& a, PaymentACK& b) {
    a.Swap(&b);
  }
  inline void Swap(PaymentACK* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PaymentACK* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PaymentACK* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PaymentACK>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PaymentACK& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PaymentACK& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PaymentACK* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "payments.PaymentACK";
  }
  protected:
  explicit PaymentACK(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMemoFieldNumber = 2,
    kPaymentFieldNumber = 1,
  };
  // optional string memo = 2;
  bool has_memo() const;
  private:
  bool _internal_has_memo() const;
  public:
  void clear_memo();
  const std::string& memo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_memo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_memo();
  PROTOBUF_NODISCARD std::string* release_memo();
  void set_allocated_memo(std::string* memo);
  private:
  const std::string& _internal_memo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_memo(const std::string& value);
  std::string* _internal_mutable_memo();
  public:

  // required .payments.Payment payment = 1;
  bool has_payment() const;
  private:
  bool _internal_has_payment() const;
  public:
  void clear_payment();
  const ::payments::Payment& payment() const;
  PROTOBUF_NODISCARD ::payments::Payment* release_payment();
  ::payments::Payment* mutable_payment();
  void set_allocated_payment(::payments::Payment* payment);
  private:
  const ::payments::Payment& _internal_payment() const;
  ::payments::Payment* _internal_mutable_payment();
  public:
  void unsafe_arena_set_allocated_payment(
      ::payments::Payment* payment);
  ::payments::Payment* unsafe_arena_release_payment();

  // @@protoc_insertion_point(class_scope:payments.PaymentACK)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr memo_;
  ::payments::Payment* payment_;
  friend struct ::TableStruct_paymentrequest_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Output

// optional uint64 amount = 1 [default = 0];
inline bool Output::_internal_has_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Output::has_amount() const {
  return _internal_has_amount();
}
inline void Output::clear_amount() {
  amount_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t Output::_internal_amount() const {
  return amount_;
}
inline uint64_t Output::amount() const {
  // @@protoc_insertion_point(field_get:payments.Output.amount)
  return _internal_amount();
}
inline void Output::_internal_set_amount(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  amount_ = value;
}
inline void Output::set_amount(uint64_t value) {
  _internal_set_amount(value);
  // @@protoc_insertion_point(field_set:payments.Output.amount)
}

// required bytes script = 2;
inline bool Output::_internal_has_script() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Output::has_script() const {
  return _internal_has_script();
}
inline void Output::clear_script() {
  script_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Output::script() const {
  // @@protoc_insertion_point(field_get:payments.Output.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Output::set_script(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 script_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.Output.script)
}
inline std::string* Output::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:payments.Output.script)
  return _s;
}
inline const std::string& Output::_internal_script() const {
  return script_.Get();
}
inline void Output::_internal_set_script(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  script_.Set(value, GetArenaForAllocation());
}
inline std::string* Output::_internal_mutable_script() {
  _has_bits_[0] |= 0x00000001u;
  return script_.Mutable(GetArenaForAllocation());
}
inline std::string* Output::release_script() {
  // @@protoc_insertion_point(field_release:payments.Output.script)
  if (!_internal_has_script()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = script_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_.IsDefault()) {
    script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Output::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  script_.SetAllocated(script, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (script_.IsDefault()) {
    script_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.Output.script)
}

// -------------------------------------------------------------------

// PaymentDetails

// optional string network = 1 [default = "main"];
inline bool PaymentDetails::_internal_has_network() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentDetails::has_network() const {
  return _internal_has_network();
}
inline void PaymentDetails::clear_network() {
  network_.ClearToDefault(::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentDetails::network() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.network)
  if (network_.IsDefault()) return _i_give_permission_to_break_this_code_default_network_.get();
  return _internal_network();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentDetails::set_network(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 network_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.network)
}
inline std::string* PaymentDetails::mutable_network() {
  std::string* _s = _internal_mutable_network();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.network)
  return _s;
}
inline const std::string& PaymentDetails::_internal_network() const {
  return network_.Get();
}
inline void PaymentDetails::_internal_set_network(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  network_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentDetails::_internal_mutable_network() {
  _has_bits_[0] |= 0x00000001u;
  return network_.Mutable(::payments::PaymentDetails::_i_give_permission_to_break_this_code_default_network_, GetArenaForAllocation());
}
inline std::string* PaymentDetails::release_network() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.network)
  if (!_internal_has_network()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = network_.Release();
  return p;
}
inline void PaymentDetails::set_allocated_network(std::string* network) {
  if (network != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  network_.SetAllocated(network, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.network)
}

// repeated .payments.Output outputs = 2;
inline int PaymentDetails::_internal_outputs_size() const {
  return outputs_.size();
}
inline int PaymentDetails::outputs_size() const {
  return _internal_outputs_size();
}
inline void PaymentDetails::clear_outputs() {
  outputs_.Clear();
}
inline ::payments::Output* PaymentDetails::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.outputs)
  return outputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
PaymentDetails::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:payments.PaymentDetails.outputs)
  return &outputs_;
}
inline const ::payments::Output& PaymentDetails::_internal_outputs(int index) const {
  return outputs_.Get(index);
}
inline const ::payments::Output& PaymentDetails::outputs(int index) const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.outputs)
  return _internal_outputs(index);
}
inline ::payments::Output* PaymentDetails::_internal_add_outputs() {
  return outputs_.Add();
}
inline ::payments::Output* PaymentDetails::add_outputs() {
  ::payments::Output* _add = _internal_add_outputs();
  // @@protoc_insertion_point(field_add:payments.PaymentDetails.outputs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
PaymentDetails::outputs() const {
  // @@protoc_insertion_point(field_list:payments.PaymentDetails.outputs)
  return outputs_;
}

// required uint64 time = 3;
inline bool PaymentDetails::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaymentDetails::has_time() const {
  return _internal_has_time();
}
inline void PaymentDetails::clear_time() {
  time_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t PaymentDetails::_internal_time() const {
  return time_;
}
inline uint64_t PaymentDetails::time() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.time)
  return _internal_time();
}
inline void PaymentDetails::_internal_set_time(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  time_ = value;
}
inline void PaymentDetails::set_time(uint64_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.time)
}

// optional uint64 expires = 4;
inline bool PaymentDetails::_internal_has_expires() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool PaymentDetails::has_expires() const {
  return _internal_has_expires();
}
inline void PaymentDetails::clear_expires() {
  expires_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t PaymentDetails::_internal_expires() const {
  return expires_;
}
inline uint64_t PaymentDetails::expires() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.expires)
  return _internal_expires();
}
inline void PaymentDetails::_internal_set_expires(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  expires_ = value;
}
inline void PaymentDetails::set_expires(uint64_t value) {
  _internal_set_expires(value);
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.expires)
}

// optional string memo = 5;
inline bool PaymentDetails::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentDetails::has_memo() const {
  return _internal_has_memo();
}
inline void PaymentDetails::clear_memo() {
  memo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentDetails::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentDetails::set_memo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.memo)
}
inline std::string* PaymentDetails::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.memo)
  return _s;
}
inline const std::string& PaymentDetails::_internal_memo() const {
  return memo_.Get();
}
inline void PaymentDetails::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentDetails::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000002u;
  return memo_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentDetails::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentDetails::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.memo)
}

// optional string payment_url = 6;
inline bool PaymentDetails::_internal_has_payment_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentDetails::has_payment_url() const {
  return _internal_has_payment_url();
}
inline void PaymentDetails::clear_payment_url() {
  payment_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaymentDetails::payment_url() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.payment_url)
  return _internal_payment_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentDetails::set_payment_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 payment_url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.payment_url)
}
inline std::string* PaymentDetails::mutable_payment_url() {
  std::string* _s = _internal_mutable_payment_url();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.payment_url)
  return _s;
}
inline const std::string& PaymentDetails::_internal_payment_url() const {
  return payment_url_.Get();
}
inline void PaymentDetails::_internal_set_payment_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  payment_url_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentDetails::_internal_mutable_payment_url() {
  _has_bits_[0] |= 0x00000004u;
  return payment_url_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentDetails::release_payment_url() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.payment_url)
  if (!_internal_has_payment_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = payment_url_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payment_url_.IsDefault()) {
    payment_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentDetails::set_allocated_payment_url(std::string* payment_url) {
  if (payment_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  payment_url_.SetAllocated(payment_url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payment_url_.IsDefault()) {
    payment_url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.payment_url)
}

// optional bytes merchant_data = 7;
inline bool PaymentDetails::_internal_has_merchant_data() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaymentDetails::has_merchant_data() const {
  return _internal_has_merchant_data();
}
inline void PaymentDetails::clear_merchant_data() {
  merchant_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PaymentDetails::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentDetails.merchant_data)
  return _internal_merchant_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentDetails::set_merchant_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 merchant_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentDetails.merchant_data)
}
inline std::string* PaymentDetails::mutable_merchant_data() {
  std::string* _s = _internal_mutable_merchant_data();
  // @@protoc_insertion_point(field_mutable:payments.PaymentDetails.merchant_data)
  return _s;
}
inline const std::string& PaymentDetails::_internal_merchant_data() const {
  return merchant_data_.Get();
}
inline void PaymentDetails::_internal_set_merchant_data(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  merchant_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentDetails::_internal_mutable_merchant_data() {
  _has_bits_[0] |= 0x00000008u;
  return merchant_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentDetails::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentDetails.merchant_data)
  if (!_internal_has_merchant_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = merchant_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (merchant_data_.IsDefault()) {
    merchant_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentDetails::set_allocated_merchant_data(std::string* merchant_data) {
  if (merchant_data != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  merchant_data_.SetAllocated(merchant_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (merchant_data_.IsDefault()) {
    merchant_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentDetails.merchant_data)
}

// -------------------------------------------------------------------

// PaymentRequest

// optional uint32 payment_details_version = 1 [default = 1];
inline bool PaymentRequest::_internal_has_payment_details_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool PaymentRequest::has_payment_details_version() const {
  return _internal_has_payment_details_version();
}
inline void PaymentRequest::clear_payment_details_version() {
  payment_details_version_ = 1u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t PaymentRequest::_internal_payment_details_version() const {
  return payment_details_version_;
}
inline uint32_t PaymentRequest::payment_details_version() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.payment_details_version)
  return _internal_payment_details_version();
}
inline void PaymentRequest::_internal_set_payment_details_version(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  payment_details_version_ = value;
}
inline void PaymentRequest::set_payment_details_version(uint32_t value) {
  _internal_set_payment_details_version(value);
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.payment_details_version)
}

// optional string pki_type = 2 [default = "none"];
inline bool PaymentRequest::_internal_has_pki_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentRequest::has_pki_type() const {
  return _internal_has_pki_type();
}
inline void PaymentRequest::clear_pki_type() {
  pki_type_.ClearToDefault(::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentRequest::pki_type() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_type)
  if (pki_type_.IsDefault()) return _i_give_permission_to_break_this_code_default_pki_type_.get();
  return _internal_pki_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentRequest::set_pki_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 pki_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_type)
}
inline std::string* PaymentRequest::mutable_pki_type() {
  std::string* _s = _internal_mutable_pki_type();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_type)
  return _s;
}
inline const std::string& PaymentRequest::_internal_pki_type() const {
  return pki_type_.Get();
}
inline void PaymentRequest::_internal_set_pki_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  pki_type_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentRequest::_internal_mutable_pki_type() {
  _has_bits_[0] |= 0x00000001u;
  return pki_type_.Mutable(::payments::PaymentRequest::_i_give_permission_to_break_this_code_default_pki_type_, GetArenaForAllocation());
}
inline std::string* PaymentRequest::release_pki_type() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_type)
  if (!_internal_has_pki_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = pki_type_.Release();
  return p;
}
inline void PaymentRequest::set_allocated_pki_type(std::string* pki_type) {
  if (pki_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pki_type_.SetAllocated(pki_type, GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_type)
}

// optional bytes pki_data = 3;
inline bool PaymentRequest::_internal_has_pki_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool PaymentRequest::has_pki_data() const {
  return _internal_has_pki_data();
}
inline void PaymentRequest::clear_pki_data() {
  pki_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& PaymentRequest::pki_data() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.pki_data)
  return _internal_pki_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentRequest::set_pki_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 pki_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.pki_data)
}
inline std::string* PaymentRequest::mutable_pki_data() {
  std::string* _s = _internal_mutable_pki_data();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.pki_data)
  return _s;
}
inline const std::string& PaymentRequest::_internal_pki_data() const {
  return pki_data_.Get();
}
inline void PaymentRequest::_internal_set_pki_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  pki_data_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentRequest::_internal_mutable_pki_data() {
  _has_bits_[0] |= 0x00000002u;
  return pki_data_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentRequest::release_pki_data() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.pki_data)
  if (!_internal_has_pki_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = pki_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pki_data_.IsDefault()) {
    pki_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentRequest::set_allocated_pki_data(std::string* pki_data) {
  if (pki_data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  pki_data_.SetAllocated(pki_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pki_data_.IsDefault()) {
    pki_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.pki_data)
}

// required bytes serialized_payment_details = 4;
inline bool PaymentRequest::_internal_has_serialized_payment_details() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool PaymentRequest::has_serialized_payment_details() const {
  return _internal_has_serialized_payment_details();
}
inline void PaymentRequest::clear_serialized_payment_details() {
  serialized_payment_details_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& PaymentRequest::serialized_payment_details() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.serialized_payment_details)
  return _internal_serialized_payment_details();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentRequest::set_serialized_payment_details(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 serialized_payment_details_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.serialized_payment_details)
}
inline std::string* PaymentRequest::mutable_serialized_payment_details() {
  std::string* _s = _internal_mutable_serialized_payment_details();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.serialized_payment_details)
  return _s;
}
inline const std::string& PaymentRequest::_internal_serialized_payment_details() const {
  return serialized_payment_details_.Get();
}
inline void PaymentRequest::_internal_set_serialized_payment_details(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  serialized_payment_details_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentRequest::_internal_mutable_serialized_payment_details() {
  _has_bits_[0] |= 0x00000004u;
  return serialized_payment_details_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentRequest::release_serialized_payment_details() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.serialized_payment_details)
  if (!_internal_has_serialized_payment_details()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = serialized_payment_details_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_payment_details_.IsDefault()) {
    serialized_payment_details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentRequest::set_allocated_serialized_payment_details(std::string* serialized_payment_details) {
  if (serialized_payment_details != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  serialized_payment_details_.SetAllocated(serialized_payment_details, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (serialized_payment_details_.IsDefault()) {
    serialized_payment_details_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.serialized_payment_details)
}

// optional bytes signature = 5;
inline bool PaymentRequest::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool PaymentRequest::has_signature() const {
  return _internal_has_signature();
}
inline void PaymentRequest::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& PaymentRequest::signature() const {
  // @@protoc_insertion_point(field_get:payments.PaymentRequest.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentRequest::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 signature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentRequest.signature)
}
inline std::string* PaymentRequest::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:payments.PaymentRequest.signature)
  return _s;
}
inline const std::string& PaymentRequest::_internal_signature() const {
  return signature_.Get();
}
inline void PaymentRequest::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  signature_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentRequest::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000008u;
  return signature_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentRequest::release_signature() {
  // @@protoc_insertion_point(field_release:payments.PaymentRequest.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = signature_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault()) {
    signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentRequest::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  signature_.SetAllocated(signature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault()) {
    signature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentRequest.signature)
}

// -------------------------------------------------------------------

// X509Certificates

// repeated bytes certificate = 1;
inline int X509Certificates::_internal_certificate_size() const {
  return certificate_.size();
}
inline int X509Certificates::certificate_size() const {
  return _internal_certificate_size();
}
inline void X509Certificates::clear_certificate() {
  certificate_.Clear();
}
inline std::string* X509Certificates::add_certificate() {
  std::string* _s = _internal_add_certificate();
  // @@protoc_insertion_point(field_add_mutable:payments.X509Certificates.certificate)
  return _s;
}
inline const std::string& X509Certificates::_internal_certificate(int index) const {
  return certificate_.Get(index);
}
inline const std::string& X509Certificates::certificate(int index) const {
  // @@protoc_insertion_point(field_get:payments.X509Certificates.certificate)
  return _internal_certificate(index);
}
inline std::string* X509Certificates::mutable_certificate(int index) {
  // @@protoc_insertion_point(field_mutable:payments.X509Certificates.certificate)
  return certificate_.Mutable(index);
}
inline void X509Certificates::set_certificate(int index, const std::string& value) {
  certificate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
}
inline void X509Certificates::set_certificate(int index, std::string&& value) {
  certificate_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:payments.X509Certificates.certificate)
}
inline void X509Certificates::set_certificate(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::set_certificate(int index, const void* value, size_t size) {
  certificate_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.X509Certificates.certificate)
}
inline std::string* X509Certificates::_internal_add_certificate() {
  return certificate_.Add();
}
inline void X509Certificates::add_certificate(const std::string& value) {
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(std::string&& value) {
  certificate_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  certificate_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.X509Certificates.certificate)
}
inline void X509Certificates::add_certificate(const void* value, size_t size) {
  certificate_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.X509Certificates.certificate)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
X509Certificates::certificate() const {
  // @@protoc_insertion_point(field_list:payments.X509Certificates.certificate)
  return certificate_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
X509Certificates::mutable_certificate() {
  // @@protoc_insertion_point(field_mutable_list:payments.X509Certificates.certificate)
  return &certificate_;
}

// -------------------------------------------------------------------

// Payment

// optional bytes merchant_data = 1;
inline bool Payment::_internal_has_merchant_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool Payment::has_merchant_data() const {
  return _internal_has_merchant_data();
}
inline void Payment::clear_merchant_data() {
  merchant_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& Payment::merchant_data() const {
  // @@protoc_insertion_point(field_get:payments.Payment.merchant_data)
  return _internal_merchant_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payment::set_merchant_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 merchant_data_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.Payment.merchant_data)
}
inline std::string* Payment::mutable_merchant_data() {
  std::string* _s = _internal_mutable_merchant_data();
  // @@protoc_insertion_point(field_mutable:payments.Payment.merchant_data)
  return _s;
}
inline const std::string& Payment::_internal_merchant_data() const {
  return merchant_data_.Get();
}
inline void Payment::_internal_set_merchant_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  merchant_data_.Set(value, GetArenaForAllocation());
}
inline std::string* Payment::_internal_mutable_merchant_data() {
  _has_bits_[0] |= 0x00000001u;
  return merchant_data_.Mutable(GetArenaForAllocation());
}
inline std::string* Payment::release_merchant_data() {
  // @@protoc_insertion_point(field_release:payments.Payment.merchant_data)
  if (!_internal_has_merchant_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = merchant_data_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (merchant_data_.IsDefault()) {
    merchant_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Payment::set_allocated_merchant_data(std::string* merchant_data) {
  if (merchant_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  merchant_data_.SetAllocated(merchant_data, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (merchant_data_.IsDefault()) {
    merchant_data_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.merchant_data)
}

// repeated bytes transactions = 2;
inline int Payment::_internal_transactions_size() const {
  return transactions_.size();
}
inline int Payment::transactions_size() const {
  return _internal_transactions_size();
}
inline void Payment::clear_transactions() {
  transactions_.Clear();
}
inline std::string* Payment::add_transactions() {
  std::string* _s = _internal_add_transactions();
  // @@protoc_insertion_point(field_add_mutable:payments.Payment.transactions)
  return _s;
}
inline const std::string& Payment::_internal_transactions(int index) const {
  return transactions_.Get(index);
}
inline const std::string& Payment::transactions(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.transactions)
  return _internal_transactions(index);
}
inline std::string* Payment::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.transactions)
  return transactions_.Mutable(index);
}
inline void Payment::set_transactions(int index, const std::string& value) {
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
}
inline void Payment::set_transactions(int index, std::string&& value) {
  transactions_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:payments.Payment.transactions)
}
inline void Payment::set_transactions(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:payments.Payment.transactions)
}
inline void Payment::set_transactions(int index, const void* value, size_t size) {
  transactions_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:payments.Payment.transactions)
}
inline std::string* Payment::_internal_add_transactions() {
  return transactions_.Add();
}
inline void Payment::add_transactions(const std::string& value) {
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
inline void Payment::add_transactions(std::string&& value) {
  transactions_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:payments.Payment.transactions)
}
inline void Payment::add_transactions(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transactions_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:payments.Payment.transactions)
}
inline void Payment::add_transactions(const void* value, size_t size) {
  transactions_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:payments.Payment.transactions)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Payment::transactions() const {
  // @@protoc_insertion_point(field_list:payments.Payment.transactions)
  return transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Payment::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.transactions)
  return &transactions_;
}

// repeated .payments.Output refund_to = 3;
inline int Payment::_internal_refund_to_size() const {
  return refund_to_.size();
}
inline int Payment::refund_to_size() const {
  return _internal_refund_to_size();
}
inline void Payment::clear_refund_to() {
  refund_to_.Clear();
}
inline ::payments::Output* Payment::mutable_refund_to(int index) {
  // @@protoc_insertion_point(field_mutable:payments.Payment.refund_to)
  return refund_to_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >*
Payment::mutable_refund_to() {
  // @@protoc_insertion_point(field_mutable_list:payments.Payment.refund_to)
  return &refund_to_;
}
inline const ::payments::Output& Payment::_internal_refund_to(int index) const {
  return refund_to_.Get(index);
}
inline const ::payments::Output& Payment::refund_to(int index) const {
  // @@protoc_insertion_point(field_get:payments.Payment.refund_to)
  return _internal_refund_to(index);
}
inline ::payments::Output* Payment::_internal_add_refund_to() {
  return refund_to_.Add();
}
inline ::payments::Output* Payment::add_refund_to() {
  ::payments::Output* _add = _internal_add_refund_to();
  // @@protoc_insertion_point(field_add:payments.Payment.refund_to)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::payments::Output >&
Payment::refund_to() const {
  // @@protoc_insertion_point(field_list:payments.Payment.refund_to)
  return refund_to_;
}

// optional string memo = 4;
inline bool Payment::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool Payment::has_memo() const {
  return _internal_has_memo();
}
inline void Payment::clear_memo() {
  memo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& Payment::memo() const {
  // @@protoc_insertion_point(field_get:payments.Payment.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Payment::set_memo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.Payment.memo)
}
inline std::string* Payment::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:payments.Payment.memo)
  return _s;
}
inline const std::string& Payment::_internal_memo() const {
  return memo_.Get();
}
inline void Payment::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  memo_.Set(value, GetArenaForAllocation());
}
inline std::string* Payment::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000002u;
  return memo_.Mutable(GetArenaForAllocation());
}
inline std::string* Payment::release_memo() {
  // @@protoc_insertion_point(field_release:payments.Payment.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void Payment::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.Payment.memo)
}

// -------------------------------------------------------------------

// PaymentACK

// required .payments.Payment payment = 1;
inline bool PaymentACK::_internal_has_payment() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || payment_ != nullptr);
  return value;
}
inline bool PaymentACK::has_payment() const {
  return _internal_has_payment();
}
inline void PaymentACK::clear_payment() {
  if (payment_ != nullptr) payment_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::payments::Payment& PaymentACK::_internal_payment() const {
  const ::payments::Payment* p = payment_;
  return p != nullptr ? *p : reinterpret_cast<const ::payments::Payment&>(
      ::payments::_Payment_default_instance_);
}
inline const ::payments::Payment& PaymentACK::payment() const {
  // @@protoc_insertion_point(field_get:payments.PaymentACK.payment)
  return _internal_payment();
}
inline void PaymentACK::unsafe_arena_set_allocated_payment(
    ::payments::Payment* payment) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(payment_);
  }
  payment_ = payment;
  if (payment) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:payments.PaymentACK.payment)
}
inline ::payments::Payment* PaymentACK::release_payment() {
  _has_bits_[0] &= ~0x00000002u;
  ::payments::Payment* temp = payment_;
  payment_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::payments::Payment* PaymentACK::unsafe_arena_release_payment() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.payment)
  _has_bits_[0] &= ~0x00000002u;
  ::payments::Payment* temp = payment_;
  payment_ = nullptr;
  return temp;
}
inline ::payments::Payment* PaymentACK::_internal_mutable_payment() {
  _has_bits_[0] |= 0x00000002u;
  if (payment_ == nullptr) {
    auto* p = CreateMaybeMessage<::payments::Payment>(GetArenaForAllocation());
    payment_ = p;
  }
  return payment_;
}
inline ::payments::Payment* PaymentACK::mutable_payment() {
  ::payments::Payment* _msg = _internal_mutable_payment();
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.payment)
  return _msg;
}
inline void PaymentACK::set_allocated_payment(::payments::Payment* payment) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete payment_;
  }
  if (payment) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(payment);
    if (message_arena != submessage_arena) {
      payment = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, payment, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payment_ = payment;
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.payment)
}

// optional string memo = 2;
inline bool PaymentACK::_internal_has_memo() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PaymentACK::has_memo() const {
  return _internal_has_memo();
}
inline void PaymentACK::clear_memo() {
  memo_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PaymentACK::memo() const {
  // @@protoc_insertion_point(field_get:payments.PaymentACK.memo)
  return _internal_memo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PaymentACK::set_memo(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 memo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:payments.PaymentACK.memo)
}
inline std::string* PaymentACK::mutable_memo() {
  std::string* _s = _internal_mutable_memo();
  // @@protoc_insertion_point(field_mutable:payments.PaymentACK.memo)
  return _s;
}
inline const std::string& PaymentACK::_internal_memo() const {
  return memo_.Get();
}
inline void PaymentACK::_internal_set_memo(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  memo_.Set(value, GetArenaForAllocation());
}
inline std::string* PaymentACK::_internal_mutable_memo() {
  _has_bits_[0] |= 0x00000001u;
  return memo_.Mutable(GetArenaForAllocation());
}
inline std::string* PaymentACK::release_memo() {
  // @@protoc_insertion_point(field_release:payments.PaymentACK.memo)
  if (!_internal_has_memo()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = memo_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PaymentACK::set_allocated_memo(std::string* memo) {
  if (memo != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  memo_.SetAllocated(memo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (memo_.IsDefault()) {
    memo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:payments.PaymentACK.memo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace payments

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_paymentrequest_2eproto
